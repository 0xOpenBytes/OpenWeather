//
//  OpenWeather template generated by OpenBytes on 22/03/2023.
//
// Created by Ahmed Shendy.
//  SearchLocationViewModel.swift
//

import Combine
import ViewModel
import Foundation
import CoreLocation

final class SearchLocationViewModel: ViewModel<
    SearchLocationViewModel.Capabilities,
    SearchLocationViewModel.Input,
    SearchLocationViewModel.Content
> {
    struct Capabilities {
        static var mock: Capabilities {
            .init(
                locationProviding: MockLocationProvider()
            )
        }

        private var locationProviding: LocationProviding

        init(locationProviding: LocationProviding) {
            self.locationProviding = locationProviding
        }

        func getLocations(query: String) async throws -> [DeviceLocation] {
            try await locationProviding.locations(for: query)
        }
    }

    struct Input: Equatable {
        var searchText: String = ""
    }

    struct Content {
        var result: [DeviceLocation]
    }

    static var mock: SearchLocationViewModel {
        .init(capabilities: .mock, input: .init())
    }

    override var input: Input {
        didSet {
            guard input != oldValue else { return }

            searchSubject.send(input.searchText)
        }
    }

    override var content: Content {
        Content(result: result)
    }

    private var errorHandler: ErrorHandler
    private let searchSubject: CurrentValueSubject<String, Never> = CurrentValueSubject("")

    private var searchTask: Task<Void, Never>?
    private var searchSubscription: AnyCancellable?

    @Published private var result: [DeviceLocation] = []

    init(
        capabilities: Capabilities,
        input: Input,
        errorHandler: ErrorHandler = ErrorHandler(
            plugins: [
                ToastErrorPlugin()
            ]
        )
    ) {
        self.errorHandler = errorHandler

        super.init(capabilities: capabilities, input: input)

        searchSubscription = searchSubject
            .removeDuplicates()
            .debounce(for: 0.300, scheduler: RunLoop.main)
            .sink { [weak self] searchText in
                self?.getLocations(searchText: searchText)
            }
    }

    private func getLocations(searchText: String) {
        searchTask?.cancel()

        searchTask = Task {
            do {
                guard searchTask?.isCancelled == false else { return }

                let result = try await capabilities.getLocations(query: searchText)

                guard searchTask?.isCancelled == false else { return }

                await MainActor.run {
                    self.result = result
                }
            } catch {
                errorHandler.handle(error: error)
            }
        }
    }
}
